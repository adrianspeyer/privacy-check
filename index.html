<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#3B82F6">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Privacy Check">
<meta name="description" content="Audit your digital footprint. See what your phone reveals.">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icon-192.png">
<link rel="icon" href="data:,"> 
<title>Privacy Check</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/adrianspeyer/speyer-ui@2.0.7/dist/sui-tokens.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/adrianspeyer/speyer-ui@2.0.7/dist/sui-components.min.css">
<script src="https://cdn.jsdelivr.net/gh/adrianspeyer/speyer-ui@2.0.7/dist/sui.min.js" defer></script>

<style>
/* ‚îÄ‚îÄ PWA Physics ‚îÄ‚îÄ */
body, html { position: fixed; width: 100%; height: 100%; overflow: hidden; background: var(--sui-bg-primary); -webkit-user-select: none; user-select: none; touch-action: pan-y; }
.app-scroller { height: 100%; overflow-y: auto; -webkit-overflow-scrolling: touch; padding-bottom: env(safe-area-inset-bottom); overscroll-behavior-y: none; }
.app-wrap { max-width: 640px; margin: 0 auto; padding: 0 var(--sui-space-3) 160px; }

/* ‚îÄ‚îÄ Sticky Action Bar ‚îÄ‚îÄ */
.action-bar { position: sticky; top: 0; z-index: 999; display: flex; justify-content: space-between; align-items: center; padding: 12px var(--sui-space-3); margin: 0 -16px; padding-left: calc(var(--sui-space-3) + env(safe-area-inset-left)); padding-right: calc(var(--sui-space-3) + env(safe-area-inset-right)); padding-top: calc(12px + env(safe-area-inset-top)); background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border-bottom: 1px solid var(--sui-border); }
[data-theme="dark"] .action-bar { background: rgba(11, 15, 26, 0.95); }
.btn-rescan { background: var(--sui-blue-primary); color: white; border: none; border-radius: 24px; padding: 8px 18px; font-size: 15px; font-weight: 600; display: flex; align-items: center; gap: 8px; box-shadow: var(--sui-shadow-sm); cursor: pointer; }
.btn-rescan:active { transform: scale(0.96); }
.btn-rescan svg { width: 18px; height: 18px; }

/* ‚îÄ‚îÄ UI Components ‚îÄ‚îÄ */
.hero { text-align: center; padding: var(--sui-space-5) var(--sui-space-3) 24px; }
.hero-icon { width: 64px; height: 64px; margin: 0 auto 16px; border-radius: var(--sui-radius-lg); background: var(--sui-blue-soft); border: 1px solid var(--sui-border); display: flex; align-items: center; justify-content: center; font-size: 30px; }

/* Report Card */
.rc-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 16px; }
.rc-col { text-align: center; padding: 16px; background: var(--sui-bg-elevated); border-radius: var(--sui-radius-lg); border: 1px solid var(--sui-border); }
.rc-label { font-size: 11px; font-weight: 700; text-transform: uppercase; color: var(--sui-text-muted); letter-spacing: 0.05em; margin-bottom: 8px; }
.rc-val-big { font-family: var(--sui-font-mono); font-size: 42px; font-weight: 700; line-height: 1; }
.rc-sub { font-size: 12px; color: var(--sui-text-secondary); margin-top: 6px; font-weight: 500; }

/* Headers */
.sec-header { font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.08em; color: var(--sui-text-muted); margin: 32px 0 12px; padding-left: 4px; display: flex; align-items: center; gap: 8px; }
.sec-line { height: 1px; background: var(--sui-border); flex: 1; }

/* Data Items */
.d-item { background: var(--sui-bg-elevated); border: 1px solid var(--sui-border); border-radius: var(--sui-radius-md); margin-bottom: 16px; overflow: hidden; }
.d-row { display: flex; align-items: flex-start; padding: 16px; gap: 16px; }
.d-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; margin-top: 6px; }
.d-dot-h { background: var(--sui-error); }
.d-dot-m { background: var(--sui-warning); }
.d-dot-s { background: var(--sui-success); }
.d-dot-l { background: var(--sui-info); opacity: 0.5; } 
.d-key { font-size: 14px; color: var(--sui-text-secondary); flex-shrink: 0; min-width: 110px; font-weight: 600; }
.d-val { font-family: var(--sui-font-mono); font-size: 14px; color: var(--sui-blue-active); text-align: right; flex: 1; overflow-wrap: anywhere; line-height: 1.6; }
.d-why { padding: 12px 16px; background: rgba(0,0,0,0.03); font-size: 13px; color: var(--sui-text-primary); border-top: 1px solid var(--sui-border); line-height: 1.5; }
.d-why-label { font-weight: 700; font-size: 11px; text-transform: uppercase; color: var(--sui-text-muted); display: block; margin-bottom: 4px; letter-spacing: 0.05em; }

/* Mobile Stack */
@media (max-width: 480px) {
  .d-row { flex-direction: column; gap: 6px; }
  .d-key { min-width: auto; margin-bottom: 2px; color: var(--sui-text-muted); font-size: 12px; text-transform: uppercase; letter-spacing:0.05em;}
  .d-val { text-align: left; width: 100%; font-size: 15px; }
  .d-dot { display: none; } 
  .d-item { border-left: 4px solid transparent; }
  .d-item.risk-h { border-left-color: var(--sui-error); }
  .d-item.risk-m { border-left-color: var(--sui-warning); }
  .d-item.risk-s { border-left-color: var(--sui-success); }
  .d-item.risk-l { border-left-color: var(--sui-border); }
}

.edu-box { background: var(--sui-blue-soft); border: 1px solid var(--sui-blue-focus); padding: 16px; border-radius: var(--sui-radius-md); margin-bottom: 16px; font-size: 14px; color: var(--sui-text-primary); line-height: 1.5; display: flex; gap: 12px; }
.edu-icon { font-size: 20px; flex-shrink: 0; margin-top: 0; }
.perm-btn { width: 100%; margin-bottom: 12px; justify-content: flex-start; border-style: dashed; padding: 14px; height: auto; }
.perm-btn.granted { border-style: solid; border-color: var(--sui-success); background: var(--sui-success-soft); color: var(--sui-success-strong); }
.perm-btn.protected { border-style: solid; border-color: var(--sui-success); background: var(--sui-bg-elevated); color: var(--sui-text-secondary); pointer-events: none; }

/* Toast */
.sui-toast-container { z-index: 2000 !important; top: 80px !important; }
.update-toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(100px); z-index: 2000; transition: transform 0.3s ease-out; width: 90%; max-width: 400px; }
.update-toast.visible { transform: translateX(-50%) translateY(0); }
</style>
</head>

<body>

<div id="update-toast" class="sui-toast sui-toast-info update-toast">
  <div class="sui-toast-icon">‚ú®</div>
  <div class="sui-toast-content">
    <div class="sui-toast-title">Update Available</div>
    <div class="sui-toast-message">New version ready.</div>
  </div>
  <button class="sui-btn sui-btn-sm sui-btn-primary" id="btn-update">Update</button>
</div>

<div class="app-scroller">
  <div class="action-bar">
    <button class="btn-rescan" id="global-rescan">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"/><path d="M1 20v-6h6"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></svg>
      Rescan
    </button>
    <label class="sui-toggle-label" style="margin:0">
      <span style="font-size:12px;color:var(--sui-text-muted);">‚òÄÔ∏è/üåô</span>
      <span class="sui-toggle">
        <input type="checkbox" id="theme-toggle">
        <span class="sui-toggle-track"></span>
      </span>
    </label>
  </div>

  <div class="app-wrap">
    <div class="hero">
      <div class="hero-icon">üõ°Ô∏è</div>
      <h1>Privacy Check</h1>
      <p>Audit your digital footprint. Adjust settings. Rescan to verify your privacy.</p>
    </div>

    <div class="sui-card sui-mb-4" id="report">
      <div class="sui-text-center"><span class="sui-badge sui-badge-neutral sui-badge-sm">LIVE STATUS</span></div>
      <div class="rc-grid">
        <div class="rc-col">
          <div class="rc-label">Security Grade</div>
          <div class="rc-val-big" id="o-grade" style="color:var(--sui-text-muted)">-</div>
          <div class="rc-sub" id="o-label">Checking...</div>
        </div>
        <div class="rc-col">
          <div class="rc-label">Footprint Bits</div>
          <div class="rc-val-big" id="s-uniq" style="color:var(--sui-blue-primary)">-</div>
          <div class="rc-sub">Uniqueness</div>
        </div>
      </div>
      <div style="margin-top:16px;padding-top:16px;border-top:1px solid var(--sui-border)">
        <div class="sui-progress sui-progress-lg" id="score-container">
          <div class="sui-progress-bar" id="score-bar" style="width:0%"></div>
        </div>
      </div>
    </div>

    <div id="sec-guide"></div>

    <div class="sec-header">‚ö†Ô∏è Actionable Security<div class="sec-line"></div></div>
    <div id="sec-actionable"></div>

    <div class="sec-header">üë£ Device Footprint<div class="sec-line"></div></div>
    <div id="sec-footprint"></div>

    <div class="sui-footer">
      <p>Data stays on device. Built with Speyer UI.</p>
      <div class="sui-mt-2"><span class="sui-badge sui-badge-neutral sui-badge-sm sui-badge-outline" id="app-version">v3.7</span></div>
    </div>
  </div>
</div>

<canvas id="fp-canvas" width="200" height="50" style="display:none"></canvas>

<script>
/* Privacy Check ‚Äî v3.7 (grade + adblock + webRTC fixes) */

const APP_VERSION = 'v3.7';
document.getElementById('app-version').innerText = APP_VERSION;

const LS_KEY = 'privacy_check_state_v1';

const RiskMap = new Map();      // actionable grade inputs
const FootprintMap = new Map(); // uniqueness only

const State = {
  isBrave: false,
  isFirefox: false,
  hasAdBlock: false,
  webRTCSafe: true
};

const Toast = {
  info(t, m){ try { window.SUI?.toast?.info?.(t, m); } catch(e) {} },
  success(t, m){ try { window.SUI?.toast?.success?.(t, m); } catch(e) {} },
  warning(t, m){ try { window.SUI?.toast?.warning?.(t, m); } catch(e) {} },
  error(t, m){ try { window.SUI?.toast?.error?.(t, m); } catch(e) {} }
};

function loadState(){
  try {
    const raw = localStorage.getItem(LS_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch(e){ return {}; }
}
function saveState(obj){
  try { localStorage.setItem(LS_KEY, JSON.stringify(obj)); } catch(e){}
}

const Persist = loadState();
const TestResults = Persist.tests || {
  contacts: null,
  files: null
};
const ThemeState = Persist.theme || null;

function setTheme(mode){
  document.documentElement.setAttribute('data-theme', mode);
  Persist.theme = mode;
  saveState(Persist);
}

function isPrivateIPv4(ip){
  // 10.0.0.0/8
  if (ip.startsWith('10.')) return true;
  // 192.168.0.0/16
  if (ip.startsWith('192.168.')) return true;
  // 172.16.0.0 - 172.31.255.255
  if (ip.startsWith('172.')) {
    const n = parseInt(ip.split('.')[1] || '0', 10);
    if (n >= 16 && n <= 31) return true;
  }
  // 169.254.0.0/16 (link-local)
  if (ip.startsWith('169.254.')) return true;
  return false;
}

const SEV = { none: 0, low: 0.25, medium: 0.5, high: 1 };

const App = {
  layout: {
    guide: ['tips'],
    actionable: ['prot', 'net', 'api', 'priv', 'sen', 'id'],
    footprint: ['hw', 'fp', 'beh', 'font', 'med', 'bat']
  },

  resetUI(){
    document.getElementById('sec-guide').innerHTML = '';
    document.getElementById('sec-actionable').innerHTML = '';
    document.getElementById('sec-footprint').innerHTML = '';
  },

  mkSec(id, icon, title, sub, eduText) {
    let containerId = 'sec-footprint';
    if (App.layout.actionable.includes(id)) containerId = 'sec-actionable';
    if (App.layout.guide.includes(id)) containerId = 'sec-guide';

    const container = document.getElementById(containerId);
    if (!container) return document.createElement('div');

    const wrap = document.createElement('div');
    wrap.className = 'sui-accordion sui-mb-4';

    const trigger = document.createElement('button');
    trigger.className = 'sui-accordion-trigger';
    trigger.setAttribute('aria-expanded', 'false');
    trigger.style.padding = '20px';
    trigger.innerHTML = `
      <span style="display:flex;align-items:center;gap:var(--sui-space-3);flex:1">
        <span style="font-size:24px">${icon}</span>
        <span>
          <span style="display:block;font-weight:700;line-height:1.2;font-size:16px">${title}</span>
          <span style="display:block;font-size:13px;color:var(--sui-text-muted);font-weight:400;margin-top:4px">${sub}</span>
        </span>
      </span>
      <svg class="sui-accordion-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
    `;

    const panel = document.createElement('div');
    panel.className = 'sui-accordion-panel';
    panel.hidden = true;
    panel.id = `panel-${id}`;
    panel.style.paddingTop = '12px';

    if (eduText) {
      const edu = document.createElement('div');
      edu.className = 'edu-box';
      edu.innerHTML = `<div class="edu-icon">‚ÑπÔ∏è</div><div>${eduText}</div>`;
      panel.appendChild(edu);
    }

    trigger.onclick = () => {
      const exp = trigger.getAttribute('aria-expanded') === 'true';
      trigger.setAttribute('aria-expanded', String(!exp));
      panel.hidden = exp;
    };

    wrap.appendChild(trigger);
    wrap.appendChild(panel);
    container.appendChild(wrap);
    return panel;
  },

  clearRisks(keys) { keys.forEach(k => RiskMap.delete(k)); },

  addItem(panel, category, key, val, why, whyTech, severity = 'none') {
    if (!panel) return;

    let dotClass = 'd-dot-l';
    let sevVal = 0;

    if (category === 'risk') {
      sevVal = SEV[severity] ?? 0;
      RiskMap.set(key, sevVal);
      dotClass =
        severity === 'high' ? 'd-dot-h' :
        severity === 'medium' ? 'd-dot-m' :
        severity === 'low' ? 'd-dot-l' :
        'd-dot-s';
    } else {
      FootprintMap.set(key, 1);
      dotClass = 'd-dot-l';
    }

    const el = document.createElement('div');
    el.className = `d-item risk-${dotClass.replace('d-dot-', '')}`;

    const whyBlock = (why || whyTech)
      ? `<div class="d-why">
           <span class="d-why-label">${category === 'risk' ? '‚ö†Ô∏è Analysis' : 'üë£ Fingerprint Data'}</span>
           <div>${why ? `<b>${why}</b> ` : ''}${whyTech || ''}</div>
         </div>`
      : '';

    el.innerHTML = `
      <div class="d-row">
        <div class="d-dot ${dotClass}"></div>
        <span class="d-key">${key}</span>
        <span class="d-val">${val || '<span>unavailable</span>'}</span>
      </div>
      ${whyBlock}
    `;
    panel.appendChild(el);
  },

  addBtn(panel, id, label, icon, onClick) {
    if (!panel) return;

    // Ensure tracked
    if (!(id in TestResults)) TestResults[id] = null;

    const resultState = TestResults[id];

    if (resultState === 'blocked') {
      this.addItem(panel, 'risk', label, 'Protected (Blocked)', 'You successfully denied access.', '', 'none');
      return;
    }

    if (resultState === 'exposed') {
      this.addItem(panel, 'risk', label, 'Exposed', 'Access previously granted.', '', 'high');
      const reset = document.createElement('button');
      reset.className = 'sui-btn sui-btn-xs sui-btn-ghost';
      reset.innerText = 'Retest';
      reset.onclick = () => {
        TestResults[id] = null;
        Persist.tests = TestResults;
        saveState(Persist);
        Toast.info('Retest', 'Ready.');
        App.init(); // rebuild cleanly
      };
      panel.appendChild(reset);
      return;
    }

    const btn = document.createElement('button');
    btn.className = 'sui-btn sui-btn-ghost perm-btn';
    btn.innerHTML = `<span style="margin-right:8px">${icon}</span> ${label}`;

    btn.onclick = async () => {
      btn.classList.add('sui-btn-loading');

      try {
        const res = await onClick(btn, panel);

        // If user cancelled, do not mark exposed
        if (res && res.status === 'cancelled') {
          btn.classList.remove('sui-btn-loading');
          Toast.info('Cancelled', 'No access granted.');
          return;
        }

        // exposed
        TestResults[id] = 'exposed';
        Persist.tests = TestResults;
        saveState(Persist);

        btn.classList.remove('sui-btn-loading', 'sui-btn-ghost');
        btn.classList.add('granted');
        this.updateGrade();
      } catch (e) {
        // blocked/denied OR unsupported ‚Äî treat as protected
        TestResults[id] = 'blocked';
        Persist.tests = TestResults;
        saveState(Persist);

        btn.remove();
        this.addItem(panel, 'risk', label, 'Protected (Blocked)', 'Access denied or unavailable.', '', 'none');
        this.updateGrade();
      }
    };

    panel.appendChild(btn);
  },

  updateGrade() {
    const gEl = document.getElementById('o-grade');
    const bEl = document.getElementById('score-bar');
    const lEl = document.getElementById('o-label');
    const uEl = document.getElementById('s-uniq');
    if (!gEl || !bEl) return;

    let total = 0;
    RiskMap.forEach(v => total += (Number(v) || 0));

    // Smooth thresholds (no Math.ceil jumps)
    let grade = 'A';
    if (total >= 4) grade = 'F';
    else if (total >= 3) grade = 'D';
    else if (total >= 2) grade = 'C';
    else if (total >= 1) grade = 'B';

    const pct =
      grade === 'A' ? 100 :
      grade === 'B' ? 90 :
      grade === 'C' ? 70 :
      grade === 'D' ? 50 : 25;

    if (uEl) uEl.innerText = (FootprintMap.size * 1.5).toFixed(0);

    const color =
      grade === 'A' ? 'var(--sui-success)' :
      grade === 'F' ? 'var(--sui-error)' :
      'var(--sui-warning)';

    gEl.innerText = grade;
    gEl.style.color = color;
    bEl.style.width = pct + '%';
    bEl.style.backgroundColor = color;

    if (lEl) {
      lEl.innerText =
        grade === 'A' ? 'Excellent' :
        grade === 'B' ? 'Good (Minor Fixes)' :
        grade === 'C' ? 'Needs Work' :
        grade === 'D' ? 'High Risk Setup' :
        'Critical Risks';
    }

    this.updateGuide();
  },

  updateGuide() {
    const panel = document.getElementById('panel-tips');
    if (!panel) return;

    const tips = [];
    const ua = navigator.userAgent || '';
    State.isBrave = navigator.brave !== undefined;
    State.isFirefox = ua.toLowerCase().includes('firefox');

    if (State.isBrave || State.isFirefox) {
      tips.push({ s: 'success', t: 'Browser: Safer Choice', d: 'You are using a privacy-focused browser.' });
    } else {
      tips.push({ s: 'warning', t: 'Browser: Standard Tracking', d: 'For stronger default privacy, consider <b>Brave</b> or <b>Firefox</b>.' });
    }

    if (State.hasAdBlock) {
      tips.push({ s: 'success', t: 'AdBlock: Active', d: 'You are blocking many tracking scripts.' });
    } else {
      tips.push({ s: 'error', t: 'AdBlock: Missing', d: '<b>Recommended:</b> Install <b>uBlock Origin</b> (or an equivalent blocker).' });
    }

    if (State.webRTCSafe) {
      tips.push({ s: 'success', t: 'WebRTC: No Public Leak Detected', d: 'This offline test did not detect a public WebRTC IP exposure.' });
    } else {
      tips.push({ s: 'warning', t: 'WebRTC: Possible Exposure', d: 'WebRTC may be exposing an address. Consider disabling WebRTC or tightening browser privacy settings.' });
    }

    panel.innerHTML = '';
    const edu = document.createElement('div');
    edu.className = 'edu-box';
    edu.innerHTML = `<div class="edu-icon">‚ÑπÔ∏è</div><div>We analyzed your settings. Here is your personalized to-do list.</div>`;
    panel.appendChild(edu);

    tips.forEach(t => {
      const div = document.createElement('div');
      div.className = `sui-alert sui-alert-${t.s} sui-mb-2`;
      div.innerHTML = `<div class="sui-alert-content"><div class="sui-alert-title">${t.t}</div><div>${t.d}</div></div>`;
      panel.appendChild(div);
    });
  },

  initTheme() {
    const toggle = document.getElementById('theme-toggle');
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const mode = ThemeState || (prefersDark ? 'dark' : 'light');
    setTheme(mode);
    toggle.checked = (mode === 'dark');
    toggle.addEventListener('change', (e) => setTheme(e.target.checked ? 'dark' : 'light'));
  },

  init() {
    // Prevent duplicate sections if init is called again
    this.resetUI();

    this.initTheme();

    this.mkSec('tips', 'üéì', 'Smart Action Plan', 'Based on your results',
      'Quick, practical fixes first. Your grade is based on the actionable security checks.');

    this.mkSec('prot', 'üõ°Ô∏è', 'Protection Check', 'AdBlock, Cookies, GPC', 'Your first line of defense.');
    this.scanProtection(document.getElementById('panel-prot'));

    this.mkSec('api', 'üö¶', 'Permissions API', 'Auto-detected settings', 'Permissions you‚Äôve already configured.');
    this.scanPermissions(document.getElementById('panel-api'));

    this.mkSec('net', 'üåê', 'Network Exposure', 'WebRTC, connection info', 'What sites can infer about your network.');
    this.scanNetwork(document.getElementById('panel-net'));

    this.mkSec('id', 'üì±', 'Identity', 'Browser, Timezone', 'Software identity signals.');
    this.scanIdentity(document.getElementById('panel-id'));

    // Footprint sections (not graded)
    this.mkSec('hw', 'üîß', 'Hardware Specs', 'Screen, CPU, RAM', 'Device properties (uniqueness, not your grade).');
    this.scanHardware(document.getElementById('panel-hw'));

    this.mkSec('fp', 'üëÅ', 'Invisible Fingerprints', 'Canvas', 'Rendering quirks trackers can use.');
    this.scanFP(document.getElementById('panel-fp'));

    this.mkSec('priv', 'üîê', 'Sensitive Access', 'Contacts, Files', 'Manual checks: only runs if you click.');
    this.scanSensitive(document.getElementById('panel-priv'));

    this.mkSec('sen', 'üì°', 'Sensors & Motion', 'Motion events', 'Manual check: only runs if you click.');
    this.scanSensors(document.getElementById('panel-sen'));

    this.mkSec('med', 'üì∑', 'Media Devices', 'Camera, Mic labels', 'Hardware device list (labels may be hidden).');
    this.scanMedia(document.getElementById('panel-med'));

    this.mkSec('bat', 'üîã', 'Battery Status', 'Level, Charging', 'Short-term tracking identifier.');
    this.scanBattery(document.getElementById('panel-bat'));

    document.getElementById('global-rescan').onclick = () => {
      Toast.success('Rescanning', 'Updating analysis...');
      this.scanProtection(document.getElementById('panel-prot'));
      this.scanPermissions(document.getElementById('panel-api'));
      this.scanNetwork(document.getElementById('panel-net'));
      this.scanIdentity(document.getElementById('panel-id'));
    };

    this.updateGrade();
  },

  async scanPermissions(p) {
    if (!p) return;
    p.innerHTML = '';
    this.clearRisks(['Geo Permission', 'Notif Permission', 'Camera Permission', 'Mic Permission']);

    if (!('permissions' in navigator) || !navigator.permissions?.query) {
      this.addItem(p, 'info', 'Permissions API', 'Unavailable', 'This browser does not expose permission states via API.');
      return;
    }

    const check = async (name, label, severityIfGranted) => {
      try {
        const result = await navigator.permissions.query({ name });
        const state = result.state; // 'granted', 'denied', 'prompt'
        let sev = 'none';
        let val = state.toUpperCase();

        if (state === 'granted') { val += ' (Exposed)'; sev = severityIfGranted; }
        if (state === 'denied') { val += ' (Protected)'; sev = 'none'; }
        if (state === 'prompt') { val += ' (Not Granted)'; sev = 'none'; }

        this.addItem(
          p,
          'risk',
          label,
          val,
          'Permission state detected by your browser.',
          '',
          sev
        );
      } catch (e) {
        this.addItem(p, 'info', label, 'Not Supported', 'This permission type isn‚Äôt exposed in this browser.');
      }
    };

    await check('geolocation', 'Geo Permission', 'high');
    await check('notifications', 'Notif Permission', 'medium');
    await check('camera', 'Camera Permission', 'high');
    await check('microphone', 'Mic Permission', 'high');

    this.updateGrade();
  },

  async scanProtection(p) {
    if (!p) return;
    p.innerHTML = '';
    this.clearRisks(['GPC Signal', 'Ad Blocker', 'Cookies']);

    const gpc = !!navigator.globalPrivacyControl;
    this.addItem(
      p,
      'risk',
      'GPC Signal',
      gpc ? 'On' : 'Off',
      'Global Privacy Control is a ‚ÄúDo Not Sell/Share‚Äù signal supported by many browsers and sites.',
      '',
      gpc ? 'none' : 'medium'
    );

    const cookiesOn = !!navigator.cookieEnabled;
    this.addItem(
      p,
      'risk',
      'Cookies',
      cookiesOn ? 'Enabled' : 'Blocked',
      'Cookies can be used for cross-site tracking unless blocked or partitioned.',
      '',
      cookiesOn ? 'medium' : 'none'
    );

    // Reliable adblock detection bait
    const bait = document.createElement('div');
    bait.className = 'adsbox ad ads-banner adsbygoogle ad-placement';
    bait.style.cssText = 'width:12px;height:12px;position:absolute;left:-9999px;top:0;background:#f00;';
    bait.innerHTML = '&nbsp;';
    document.body.appendChild(bait);

    await new Promise(r => setTimeout(r, 80));

    const cs = window.getComputedStyle(bait);
    const blocked =
      cs.display === 'none' ||
      cs.visibility === 'hidden' ||
      bait.offsetParent === null ||
      bait.offsetHeight === 0;

    bait.remove();

    State.hasAdBlock = blocked;

    this.addItem(
      p,
      'risk',
      'Ad Blocker',
      blocked ? 'Active' : 'Missing',
      blocked ? 'Great: many tracking scripts will be blocked.' : 'Trackers and ad scripts will load normally.',
      blocked ? '' : 'Installing an ad blocker is one of the highest-impact privacy wins.',
      blocked ? 'none' : 'high'
    );

    this.updateGrade();
  },

  async scanNetwork(p) {
    if (!p) return;
    p.innerHTML = '';
    this.clearRisks(['WebRTC Public Exposure']);

    const h = document.createElement('div');
    h.innerHTML = `<button class="sui-btn sui-btn-sm sui-btn-secondary" style="width:100%;margin-bottom:16px;padding:12px">‚Üª Refresh Network</button>`;
    h.onclick = () => this.scanNetwork(p);
    p.appendChild(h);

    if (navigator.connection) {
      this.addItem(p, 'info', 'Connection', navigator.connection.effectiveType || 'unknown', 'Approximate connection type.');
    }

    // Offline-only WebRTC test (no STUN servers)
    // This cannot reliably detect "VPN on/off". It can only show local candidate behavior.
    try {
      const pc = new RTCPeerConnection({ iceServers: [] });
      pc.createDataChannel('x');

      const found = { ips: new Set(), mdns: new Set() };

      pc.onicecandidate = (e) => {
        if (!e.candidate || !e.candidate.candidate) return;
        const cand = e.candidate.candidate;
        const parts = cand.split(' ');
        const addr = parts[4] || '';

        if (/^\d{1,3}(\.\d{1,3}){3}$/.test(addr)) found.ips.add(addr);
        if (addr.endsWith('.local')) found.mdns.add(addr);
      };

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      await new Promise(r => setTimeout(r, 900));
      pc.close();

      // Show what we saw
      if (found.ips.size) {
        const ips = Array.from(found.ips).slice(0, 5);
        const anyPublic = ips.some(ip => !isPrivateIPv4(ip));
        const anyPrivate = ips.some(ip => isPrivateIPv4(ip));

        if (anyPublic) {
          State.webRTCSafe = false;
          this.addItem(
            p,
            'risk',
            'WebRTC Public Exposure',
            ips.join(', '),
            'A public IP address was observed in WebRTC candidates.',
            'This can be used to infer your network identity. Consider disabling WebRTC or tightening privacy settings.',
            'high'
          );
        } else if (anyPrivate) {
          State.webRTCSafe = true;
          this.addItem(
            p,
            'info',
            'WebRTC Candidates',
            ips.join(', '),
            'Local/private network addresses are commonly visible via WebRTC.',
            'This offline test does not contact external servers, so it cannot confirm VPN status.',
          );
        }
      } else if (found.mdns.size) {
        State.webRTCSafe = true;
        this.addItem(
          p,
          'info',
          'WebRTC Candidates',
          'mDNS Hostnames',
          'This browser is using mDNS hostnames instead of raw local IPs.',
          'That‚Äôs generally better for local-IP privacy.'
        );
      } else {
        State.webRTCSafe = true;
        this.addItem(
          p,
          'info',
          'WebRTC',
          'No candidates observed',
          'Some browsers limit candidate visibility in certain contexts.',
          'This is not a definitive ‚ÄúVPN check.‚Äù'
        );
      }

      // Explicit expectation-setter
      this.addItem(
        p,
        'info',
        'VPN Status',
        'Not measurable offline',
        'Detecting VPN on/off reliably requires checking your public IP via an external service (this tool does not do that).'
      );

    } catch (e) {
      State.webRTCSafe = true;
      this.addItem(
        p,
        'info',
        'WebRTC',
        'Unavailable',
        'WebRTC APIs are blocked or unsupported in this browser.'
      );
    }

    this.updateGrade();
  },

  scanIdentity(p) {
    if (!p) return;
    p.innerHTML = '';
    this.clearRisks(['Browser Privacy']);

    const ua = navigator.userAgent || '';
    State.isBrave = navigator.brave !== undefined;
    State.isFirefox = ua.toLowerCase().includes('firefox');
    const isChrome = /Chrome/.test(ua) && /Google Inc/.test(navigator.vendor || '') && !State.isBrave;

    this.addItem(
      p,
      'risk',
      'Browser Privacy',
      isChrome ? 'Standard Chrome' : 'Privacy-Focused (Detected)',
      isChrome ? 'Chrome defaults are less privacy-protective.' : 'A privacy-focused browser was detected.',
      isChrome ? 'Brave/Firefox tend to reduce passive tracking by default.' : '',
      isChrome ? 'medium' : 'none'
    );

    this.addItem(p, 'info', 'User Agent', ua, 'Browser ‚ÄúID card‚Äù (often unique).');
    this.addItem(p, 'info', 'Timezone', Intl.DateTimeFormat().resolvedOptions().timeZone || 'unknown');
  },

  scanHardware(p) {
    if (!p) return;
    p.innerHTML = '';
    this.addItem(p, 'info', 'Screen', `${screen.width}x${screen.height}`);
    this.addItem(p, 'info', 'Cores', navigator.hardwareConcurrency || 'unknown');
    this.addItem(p, 'info', 'RAM', navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'unknown');
    this.updateGrade();
  },

  scanFP(p) {
    if (!p) return;
    p.innerHTML = '';
    try {
      const cv = document.getElementById('fp-canvas');
      const ctx = cv.getContext('2d');
      ctx.textBaseline='top'; ctx.font='14px Arial';
      ctx.fillStyle='#f60'; ctx.fillRect(125,1,62,20);
      ctx.fillStyle='#069'; ctx.fillText('Privacy!',2,15);
      const s = cv.toDataURL();
      let h = 0x811c9dc5;
      for (let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h += (h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24); }
      const hash = (h>>>0).toString(16).toUpperCase();
      this.addItem(p, 'info', 'Canvas ID', hash, 'A rendering-based fingerprint signal.');
    } catch(e){}
    this.updateGrade();
  },

  scanSensors(p) {
    if (!p) return;
    p.innerHTML = '';

    this.addBtn(p, 'motion', 'Test Motion / Gyroscope', 'üì°', async () => {
      // iOS requires permission for motion
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        const resp = await DeviceMotionEvent.requestPermission();
        if (resp !== 'granted') {
          this.addItem(p, 'risk', 'Motion', 'Protected (Denied)', 'Motion permission was denied.', '', 'none');
          this.updateGrade();
          return { status: 'cancelled' };
        }
      }

      let gotEvent = false;

      const handler = (e) => {
        gotEvent = true;
      };

      window.addEventListener('devicemotion', handler, { once: true });

      await new Promise(r => setTimeout(r, 900));
      window.removeEventListener('devicemotion', handler);

      if (gotEvent) {
        this.addItem(p, 'risk', 'Motion', 'Exposed', 'Sites can read device motion signals when allowed.', '', 'medium');
        this.updateGrade();
        return { status: 'exposed' };
      } else {
        this.addItem(p, 'risk', 'Motion', 'Protected / Unavailable', 'No motion events observed.', 'This may be blocked by browser policy or device settings.', 'none');
        this.updateGrade();
        return { status: 'cancelled' };
      }
    });
  },

  scanSensitive(p) {
    if (!p) return;
    p.innerHTML = '';
    this.clearRisks(['Contacts', 'Files']);

    this.addBtn(p, 'contacts', 'Test Contacts', 'üë•', async () => {
      if (!navigator.contacts || !navigator.contacts.select) throw new Error('Contacts API not supported');

      try {
        await navigator.contacts.select(['name'], { multiple: true });
        this.addItem(p, 'risk', 'Contacts', 'Exposed', 'You granted access to contacts.', '', 'high');
        this.updateGrade();
        return { status: 'exposed' };
      } catch (e) {
        if (e && (e.name === 'AbortError' || String(e).toLowerCase().includes('abort'))) {
          return { status: 'cancelled' };
        }
        throw e;
      }
    });

    this.addBtn(p, 'files', 'Test File Picker', 'üìÇ', async () => {
      try {
        if ('showOpenFilePicker' in window) {
          await window.showOpenFilePicker();
        } else {
          // Fallback: input picker (does not grant continuous access)
          const i = document.createElement('input');
          i.type = 'file';
          i.click();
        }
        this.addItem(p, 'risk', 'Files', 'Exposed', 'You opened a file picker (user-initiated access).', '', 'medium');
        this.updateGrade();
        return { status: 'exposed' };
      } catch (e) {
        if (e && (e.name === 'AbortError' || String(e).toLowerCase().includes('abort'))) {
          return { status: 'cancelled' };
        }
        throw e;
      }
    });
  },

  scanMedia(p) {
    if (!p) return;
    p.innerHTML = '';
    this.addBtn(p, 'media', 'Scan Devices', 'üì∑', async () => {
      if (!navigator.mediaDevices?.enumerateDevices) throw new Error('MediaDevices not supported');
      const devs = await navigator.mediaDevices.enumerateDevices();
      devs.forEach(d => this.addItem(p, 'info', d.kind, d.label || 'Hidden', 'Device labels are often hidden until permission is granted.'));
      this.updateGrade();
      return { status: 'exposed' };
    });
  },

  scanBattery(p) {
    if (!p) return;
    p.innerHTML = '';
    if (navigator.getBattery) {
      navigator.getBattery().then(b => {
        this.addItem(p, 'info', 'Level', `${(b.level*100).toFixed(0)}%`, 'Battery can be used as a short-lived identifier.');
        this.updateGrade();
      });
    } else {
      this.addItem(p, 'info', 'Battery', 'Unavailable', 'Battery API not exposed in this browser.');
      this.updateGrade();
    }
  }
};

document.addEventListener('DOMContentLoaded', () => App.init());

// PWA Logic
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').then(reg => {
    if (reg.waiting) showUpdateToast(reg.waiting);
    reg.onupdatefound = () => {
      const newWorker = reg.installing;
      newWorker.onstatechange = () => {
        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) showUpdateToast(newWorker);
      };
    };
  });
  navigator.serviceWorker.addEventListener('controllerchange', () => window.location.reload());
}
function showUpdateToast(worker) {
  const t = document.getElementById('update-toast'); t.classList.add('visible');
  document.getElementById('btn-update').onclick = () => worker.postMessage({ type: 'SKIP_WAITING' });
}
</script>

</body>
</html>
